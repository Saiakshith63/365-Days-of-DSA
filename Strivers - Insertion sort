Today, I explored Insertion Sort, another fundamental sorting algorithm that works similarly to how we sort playing cards in our hands! ðŸƒâœ¨

ðŸ”¹ What is Insertion Sort?
Insertion Sort builds the sorted array one element at a time by placing each element in its correct position. ðŸ”„

ðŸ”¹ How does it work?
1ï¸âƒ£ Consider the first element as sorted.
2ï¸âƒ£ Pick the next element and compare it with the sorted part.
3ï¸âƒ£ Shift elements if needed to make space for the new element.
4ï¸âƒ£ Repeat until the array is sorted.

ðŸ’¡ Time Complexity:
Best Case (Already Sorted): O(n) âœ…
Worst/Average Case: O(nÂ²) âŒ

ðŸ”¹ Why Use Insertion Sort?
âœ… Simple & easy to implement.
âœ… Efficient for small or nearly sorted datasets.
âœ… Stable sorting algorithm (maintains the relative order of equal elements).

ðŸ”¹ Key Learnings Today:
ðŸ“Œ Insertion Sort is more efficient than Bubble Sort for small datasets.
ðŸ“Œ Works great when the array is partially sorted.
ðŸ“Œ Helps in understanding adaptive sorting techniques.


today problem solved : Insertion sort(GFG)
------------------------------------------


class Solution:
    #Function to sort the array using bubble sort algorithm.
    def bubbleSort(self,arr):
        # code here
        n=len(arr) # len of arr
        for i in range(n-1,-1,-1): # no.of steps
        
            for j in range(i): # inner loop
            
                if arr[j]>arr[j+1]: #swap condition
                
                    arr[j],arr[j+1] = arr[j+1], arr[j] 
                    #swap between 2 values


# time complexity : O(n^2) - for average and worst case
                  : O(N) - for best case   
