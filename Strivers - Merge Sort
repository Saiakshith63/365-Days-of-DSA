Today, I explored Merge Sort, one of the most efficient sorting algorithms based on the Divide & Conquer strategy! ğŸ’¡âœ¨

ğŸ”¹ What is Merge Sort?

Merge Sort divides the array into smaller subarrays, sorts them individually, and then merges them back in a sorted manner. ğŸ§©

ğŸ”¹ How does it work?

1ï¸âƒ£ Divide the array into two halves recursively until each subarray has one element.
2ï¸âƒ£ Conquer by sorting and merging the subarrays back together.
3ï¸âƒ£ Combine them into a single sorted array.

ğŸ’¡ Time Complexity:

Best Case: O(n log n) âœ…
Worst/Average Case: O(n log n) âœ…

Space Complexity: O(n) (extra space needed for merging)

ğŸ”¹ Why Use Merge Sort?
âœ… Efficient: Always runs in O(n log n), unlike Bubble or Insertion Sort.
âœ… Stable Sorting Algorithm: Maintains relative order of equal elements.
âœ… Great for Large Datasets: Works well with linked lists and external sorting.

ğŸ”¹ Key Learnings Today:
ğŸ“Œ Merge Sort is faster than O(nÂ²) sorting algorithms.
ğŸ“Œ Itâ€™s not in-place, as it requires extra space for merging.
ğŸ“Œ Used in real-world applications like external sorting (large datasets that donâ€™t fit in memory).




Today Problem : Merge Sort (GeeksforGeeks)
------------------------------------------

class Solution:

    def merge(self,arr,low,mid,high):
        temp=[]
        left=low
        right=mid+1
        
        while left<=mid and right<=high :
            if arr[left]<=arr[right]:
                temp.append(arr[left])
                left += 1
            else :
                temp.append(arr[right])
                right +=1
                
        while left<=mid :
            temp.append(arr[left])
            left += 1
            
        while right<=high :
            temp.append(arr[right])
            right += 1
            
        for i in range(low,high+1)    :
            arr[i]=temp[i-low]
        
    def mS(self,arr,low,high):


        if low >= high :
            return 
        mid=(low+high)//2
        self.mS(arr,low,mid)
        self.mS(arr,mid+1,high)
        self.merge(arr,low,mid,high)
 
    def mergeSort(self,arr, l, r):
        #code here
        self.mS(arr,l,r)
        return arr
